# テスト駆動開発の実践メモ

## TODOリスト
- [ ] $5 + 10 CHF = $10（レートが2:1の場合）
- [ ] $5 + $5 = $10
- [x] $5 * 2 = $10
- [x] amountをprivateにする
- [x] Dollarの副作用をどうする？
- [x] Moneyの丸め処理をどうする？
- [x] equals()の実装
- [ ] hashCode()の実装
- [x] nullとの等価性比較
- [x] 他のオブジェクトとの等価性比較
- [ ] Francの追加
- [ ] 重複の除去
- [ ] equalsの一般化
- [ ] timesの一般化

## 第1章：仮実装

### チェックポイント
- [x] 最初の失敗するテストを書く
- [x] 仮実装でテストを通す
- [x] 実装を改善する

### TDDサイクルの実行メモ

#### RED
- テストの意図：最もシンプルな機能から始める（Dollar型の掛け算）
- 実装する機能：金額と数値を掛け合わせる基本的な計算
- 期待される失敗：クラスが存在しないことによるコンパイルエラー

#### GREEN
- 仮実装の方針：最小限のコードでテストを通す
- 最小限の実装内容：ハードコードされた値を返す
- 検証ポイント：テストが通ることのみを目的とする

#### REFACTORING
- リファクタリングの目的：実際の計算ロジックの実装
- 改善ポイント：ハードコードから実際の計算への移行
- 設計の意図：金額を扱うクラスの基本構造の確立

### 気づき・学び
- TDDのプラクティスについて
  - 最小限の失敗するテストから始めることの重要性
  - 仮実装の役割と意義
  - テストが先にあることで、必要最小限の実装に集中できる
- 設計の選択について
  - 金額を扱うクラスの責務の明確化
  - 値オブジェクトとしての設計の検討
  - 可視性（public/private）の検討が必要
- TypeScriptでの実装のポイント
  - クラス定義とアクセス修飾子の使用
  - 型安全性の確保
  - メソッドの戻り値の型定義の重要性

## 第2章：明白な実装

### 作業の進め方

#### 1. 各サイクルの開始時
- [ ] 現在の問題点の特定
- [ ] 変更目的の明確化
- [ ] 期待される結果の記述

#### 2. RED（テスト作成/修正）
- [ ] テストコードの追加/修正
- [ ] テストの失敗を確認
- [ ] コミット
  - メッセージ形式：`test: 〇〇のテストを追加`
  - 説明：テストの意図と期待される失敗を記述

#### 3. GREEN（実装）
- [ ] 最小限の実装を追加
- [ ] テストの成功を確認
- [ ] コミット
  - メッセージ形式：`feat: 〇〇の機能を実装`
  - 説明：実装内容と選択理由を記述

#### 4. REFACTOR（改善）
- [ ] コードの改善
- [ ] テストの維持を確認
- [ ] コミット
  - メッセージ形式：`refactor: 〇〇を改善`
  - 説明：改善内容と理由を記述

#### 5. サイクル完了時
- [ ] 学びと気づきの記録
- [ ] 次のサイクルの課題の特定
- [ ] 変更履歴の確認

### 実装サイクル

### 第1回サイクル：値オブジェクトの副作用除去

#### 現状の課題
- Dollarクラスのtimesメソッドに副作用がある
- オブジェクトの状態が変更されてしまう
- 値オブジェクトとしての性質が保たれていない

#### 変更目的
- timesメソッドを副作用のない実装に変更
- 新しいインスタンスを返す設計への移行
- 値オブジェクトとしての性質の確保

#### 期待される結果
- timesメソッドが新しいDollarインスタンスを返す
- 元のオブジェクトの状態が変更されない
- テストが意図通りに通過する

#### RED
- テストの意図：副作用の問題を明確にする
- 実装する機能：値オブジェクトとしての振る舞い
- 期待される失敗：オブジェクトの状態が変化してしまう

#### GREEN
- 仮実装の方針：新しいオブジェクトを返す実装
- 最小限の実装内容：計算結果を持つ新しいインスタンスの作成
- 検証ポイント：副作用がないことの確認

#### REFACTORING
- リファクタリングの目的：値オブジェクトの不変性の確保
- 改善ポイント：メソッドの戻り値の型定義
- 設計の意図：副作用のない計算の実現

## 第3章：三角測量

### 第1回サイクル：equals()の実装

#### 現状の課題
- Dollarオブジェクトの等価性が実装されていない
- 同じ金額を表す異なるインスタンスが等価と判定されない
- 値オブジェクトとしての基本機能が不足している

#### 変更目的
- equals()メソッドの実装
- 値オブジェクトとしての等価性の確保
- 三角測量による実装の検証

#### 期待される結果
- 同じ金額のDollarインスタンスが等価と判定される
- 異なる金額のDollarインスタンスが等価でないと判定される
- テストによる実装の正しさの確認

#### RED
- テストの意図：値オブジェクトの等価性を確認
- 実装する機能：equals()メソッドによる等価性判定
- 期待される失敗：メソッドが未実装

#### GREEN
- 仮実装の方針：最小限の実装から開始
- 最小限の実装内容：金額の比較による等価性判定
- 検証ポイント：同じ金額のインスタンスが等価と判定される

#### REFACTORING
- リファクタリングの目的：型の安全性の確保
- 改善ポイント：
  - nullや他の型のオブジェクトとの比較に対応
  - instanceofによる型チェックの追加
- 設計の意図：堅牢な等価性判定の実現

### 気づき・学び
- 三角測量について
  - シンプルなテストから始めて徐々に複雑なケースに対応
  - 複数のテストケースによる実装の正しさの確認
- 値オブジェクトの設計
  - 等価性の重要性
  - 型の安全性の確保
  - 不変性の維持
- TypeScriptでの実装のポイント
  - instanceofを使用した型チェック
  - anyの適切な使用
  - 型安全性とJavaScriptの動的な性質のバランス

### 次のサイクルでの課題
- [ ] 通貨の概念の導入
- [ ] 他の金額演算の実装
- [ ] より複雑な等価性の検討

## 第4章：プライバシー

### 第1回サイクル：テストの表現方法の改善

#### 現状の課題
- テストコードが実装の詳細（getAmount）に依存している
- 中間変数の使用により意図が分かりにくい
- 値オブジェクトの等価性が活用されていない

#### 変更目的
- テストコードの意図を明確にする
- 実装の詳細への依存を減らす
- 値オブジェクトの特性を活用する

#### 期待される結果
- より読みやすく意図が明確なテスト
- 実装の詳細に依存しないテスト
- 値オブジェクトの等価性を活用したテスト

### 気づき・学び
- テストコードの品質について
  - テストも実装と同様に改善の対象となる
  - 意図が明確なテストはドキュメントとしても機能する
  - 実装の詳細への依存は避けるべき
- 値オブジェクトの活用
  - 等価性の比較による意図の明確な表現
  - 実装の詳細を隠蔽することの重要性

## 第5章：原則をあえて破るとき

### 第1回サイクル：Francクラスの追加

#### 現状の課題
- 異なる通貨（フラン）の表現が必要
- Dollarクラスと同様の振る舞いが必要
- コードの重複が発生する可能性

#### 変更目的
- Francクラスの実装
- 通貨の概念の導入への準備
- テストによる振る舞いの確認

#### 期待される結果
- フランの掛け算が正しく動作する
- Dollarと同様の振る舞いが確認できる
- 将来的なリファクタリングの準備

#### RED
- テストの意図：フランの掛け算の振る舞いを確認
- 実装する機能：Francクラスの基本機能
- 期待される失敗：クラスが存在しないことによるコンパイルエラー

#### GREEN
- 仮実装の方針：Dollarクラスを参考にした実装
- 最小限の実装内容：金額の掛け算と等価性の判定
- 検証ポイント：テストが期待通りに動作すること

#### REFACTORING
- リファクタリングの目的：コードの重複に対する認識
- 改善ポイント：
  - DollarとFrancの類似コード
  - 将来的な通貨概念の導入の必要性
- 設計の意図：段階的な抽象化の準備

### 気づき・学び
- 重複の扱いについて
  - 一時的な重複は許容される
  - 明確な共通化のタイミングを見極めることの重要性
  - 早すぎる抽象化を避ける
- テスト駆動開発の原則
  - 必要になるまで設計を複雑にしない
  - 重複があっても、まず動くことを優先
  - リファクタリングのタイミングを見極める

### 次のサイクルでの課題
- [ ] DollarとFrancの重複除去
- [ ] 通貨概念の導入
- [ ] equalsの一般化
